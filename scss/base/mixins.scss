@use 'sass:math';
@use 'sass:list';
@use 'sass:meta';

@mixin font($font_name, $file_name, $weight, $style) {
    @font-face {
        font-family: $font_name;
        font-style: #{$style};
        font-weight: #{$weight};
        src:
            url('../fonts/#{$file_name}.woff2') format('woff2'),
            url('../fonts/#{$file_name}.woff') format('woff');
        font-display: swap;
    }
}

@mixin set-text($size, $height, $weight) {
    font-size: $size;
    line-height: $height;
    font-weight: $weight;
}

@function rem($px) {
    $result: math.div($px, 16) + rem;

    @return $result;
}

@function size($size-in-px) {
    @return calc($size-in-px / $fz-default * 1rem);
}

@function size-desktop($size-in-px) {
    @return calc($size-in-px / $vp-1920 * 100vw);
}

// Desktop first

@mixin vp-1919 {
    @media (max-width: ($vp-1920 - 1px)) {
        @content;
    }
}

@mixin vp-1439 {
    @media (max-width: ($vp-1440 - 1px)) {
        @content;
    }
}

@mixin vp-1279 {
    @media (max-width: ($vp-1280 - 1px)) {
        @content;
    }
}

@mixin vp-1023 {
    @media (max-width: ($vp-1024 - 1px)) {
        @content;
    }
}

@mixin vp-767 {
    @media (max-width: ($vp-768 - 1px)) {
        @content;
    }
}

@mixin vp-374 {
    @media (max-width: ($vp-375 - 1px)) {
        @content;
    }
}

@function em($px, $current: 16) {
    $result: math.div($px, $current) + em;

    @return $result;
}

/**
 * Миксин для создания адаптивных значений с плавным масштабированием
 *
 * @param {string} $property - CSS свойство (например: 'font-size', 'padding', 'margin')
 * @param {number} $startSize - Размер на максимальной ширине ($widthFrom) - БОЛЬШЕЕ значение
 * @param {number} $minSize - Размер на минимальной ширине ($widthTo) - МЕНЬШЕЕ значение
 * @param {number} $keepSize - Флаг сохранения размера (0 - по умолчанию, 1-3 - варианты фиксации)
 * @param {number} $widthFrom - Максимальная ширина экрана для масштабирования (по умолчанию: $containerWidth)
 * @param {number} $widthTo - Минимальная ширина экрана для масштабирования (по умолчанию: $minWidth)
 *
 * @example
 * // Размер шрифта от 14px (на 1440px) до 16px (на 1920px)
 * @include adaptive-value('font-size', 16, 14, 0, 1920, 1440);
 *
 * @example
 * // Padding от 20px (на 375px) до 40px (на 1420px)
 * @include adaptive-value('padding', 40, 20);
 *
 * @example
 * // Для десктопа: от 14px (1440px) до 18px (1920px)
 * @include adaptive-value('font-size', 18, 14, 0, $maxWidth, 1440);
 *
 * @note
 * - $startSize должен быть БОЛЬШЕ $minSize (если нужно увеличение при росте экрана)
 * - $startSize должен быть МЕНЬШЕ $minSize (если нужно уменьшение при росте экрана)
 * - $widthFrom должен быть БОЛЬШЕ $widthTo
 * - На экранах больше $widthFrom применяется фиксированный $startSize
 * - На экранах меньше $widthTo применяется фиксированный $minSize
 * - Между $widthTo и $widthFrom происходит плавное масштабирование
 */
@mixin adaptive-value($property, $startSize, $minSize, $keepSize: 0, $widthFrom: $containerWidth, $widthTo: $minWidth) {
    @if $startSize == 0 {
        $startSize: 0.0001;
    }

    @if $minSize == 0 {
        $minSize: 0.0001;
    }

    $addSize: math.div($startSize - $minSize, 16);

    @if $widthFrom == $containerWidth and $maxWidthContainer == 0 {
        $widthFrom: $maxWidth;
    }

    // Извлекаем числовые значения без единиц
    $widthFromNum: if(math.is-unitless($widthFrom), $widthFrom, $widthFrom / 1px);
    $widthToNum: if(math.is-unitless($widthTo), $widthTo, $widthTo / 1px);

    $widthFromMedia: em($widthFromNum);
    $widthToMedia: em($widthToNum);
    $slope: math.div(($startSize - $minSize), ($widthFromNum - $widthToNum));
    $yIntersection: -$widthToNum * $slope + $minSize;

    @if $yIntersection == 0 {
        $yIntersection: 0.0001;
    }

    $slopeVw: $slope * 100;
    $flyValue: #{rem($yIntersection)}' + ' #{$slopeVw}vw;
    $propertyValue: #{'clamp(' rem($minSize) ',' $flyValue ',' rem($startSize) ')'};

    @if $minSize > $startSize {
        $propertyValue: #{'clamp(' rem($startSize) ',' $flyValue ',' rem($minSize) ')'};
    }

    @if $keepSize != 1 and $keepSize != 3 {
        @media (min-width: $widthFromMedia) {
            #{$property}: rem($startSize);
        }
    }

    @media (min-width: $widthToMedia) and (max-width: $widthFromMedia) {
        @supports (#{$property}: $propertyValue) {
            #{$property}: $propertyValue;
        }

        @supports not (#{$property}: $propertyValue) {
            #{$property}: calc(
                #{rem($minSize)} + #{$addSize} * (100vw - #{rem($widthTo)}) /
                    #{math.div($widthFrom, 16) - math.div($widthTo, 16)}
            );
        }
    }

    @if $keepSize != 1 and $keepSize != 2 {
        @media (max-width: $widthToMedia) {
            #{$property}: rem($minSize);
        }
    }
}

@mixin image() {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
}

@mixin hide-scroll() {
    &::-webkit-scrollbar {
        display: none;
    }
}

@mixin responsive-video() {
    position: relative;
    aspect-ratio: 16/9;
    overflow: hidden;

    video,
    iframe,
    object,
    embed {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
    }
}

@mixin hover() {
    @media (any-hover: hover) {
        &:hover {
            @content;
        }
    }
}

/**
 * Миксин для создания теней (box-shadow)
 *
 * @param {number|list} $x - Смещение по горизонтали или массив теней
 * @param {number} $y - Смещение по вертикали (по умолчанию: 0)
 * @param {number} $blur - Размытие (по умолчанию: 0)
 * @param {number} $spread - Распространение (по умолчанию: 0)
 * @param {color} $color - Цвет тени (по умолчанию: rgba(0, 0, 0, 0.1))
 * @param {number} $opacity - Прозрачность (0-1, по умолчанию: берется из $color или 0.1)
 *
 * @example
 * // Простая тень
 * @include shadow(0, 4, 12, 0, rgba(0, 0, 0, 0.1));
 *
 * @example
 * // Тень с прозрачностью
 * @include shadow(0, 1.06, 0.9, 0, #000000, 0.0383);
 *
 * @example
 * // Множественные тени (передать массив)
 * @include shadow((
 *     rem(0) rem(1.06) rem(0.9) rem(0) rgba(0, 0, 0, 0.0383),
 *     rem(0) rem(2.42) rem(2.05) rem(0) rgba(0, 0, 0, 0.0557)
 * ));
 *
 * @example
 * // Множественные тени через список параметров (каждая тень - отдельный список)
 * @include shadow((0, 1.06, 0.9, 0, rgba(0, 0, 0, 0.0383)), (0, 2.42, 2.05, 0, rgba(0, 0, 0, 0.0557)));
 */
@mixin shadow($x: 0, $y: 0, $blur: 0, $spread: 0, $color: rgba(0, 0, 0, 0.1), $opacity: null) {
    // Проверяем, переданы ли множественные тени как отдельные аргументы-списки
    @if meta.type-of($x) == 'list' and meta.type-of($y) == 'list' and list.length($x) >= 5 and list.length($y) >= 5 {
        // Множественные тени переданы как отдельные аргументы
        $shadows: ();
        
        // Обрабатываем первую тень ($x)
        $shadowX1: list.nth($x, 1);
        $shadowY1: list.nth($x, 2);
        $shadowBlur1: list.nth($x, 3);
        $shadowSpread1: list.nth($x, 4);
        $shadowColor1: list.nth($x, 5);
        $shadowOpacity1: if(list.length($x) > 5, list.nth($x, 6), null);
        
        @if $shadowOpacity1 != null {
            $shadowColor1: rgba(red($shadowColor1), green($shadowColor1), blue($shadowColor1), $shadowOpacity1);
        }
        
        $shadows: list.append(
            $shadows,
            rem($shadowX1) rem($shadowY1) rem($shadowBlur1) rem($shadowSpread1) $shadowColor1,
            comma
        );
        
        // Обрабатываем вторую тень ($y)
        $shadowX2: list.nth($y, 1);
        $shadowY2: list.nth($y, 2);
        $shadowBlur2: list.nth($y, 3);
        $shadowSpread2: list.nth($y, 4);
        $shadowColor2: list.nth($y, 5);
        $shadowOpacity2: if(list.length($y) > 5, list.nth($y, 6), null);
        
        @if $shadowOpacity2 != null {
            $shadowColor2: rgba(red($shadowColor2), green($shadowColor2), blue($shadowColor2), $shadowOpacity2);
        }
        
        $shadows: list.append(
            $shadows,
            rem($shadowX2) rem($shadowY2) rem($shadowBlur2) rem($shadowSpread2) $shadowColor2,
            comma
        );
        
        & {
            box-shadow: $shadows;
        }
    } @else if meta.type-of($x) == 'list' and list.length($x) > 0 {
        // Проверяем, является ли первый элемент списком (множественные тени)
        $firstItem: list.nth($x, 1);
        @if meta.type-of($firstItem) == 'list' {
            // Множественные тени переданы как список списков
            $shadows: ();
            @each $shadow in $x {
                $shadowX: list.nth($shadow, 1);
                $shadowY: list.nth($shadow, 2);
                $shadowBlur: list.nth($shadow, 3);
                $shadowSpread: list.nth($shadow, 4);
                $shadowColor: list.nth($shadow, 5);
                $shadowOpacity: if(list.length($shadow) > 5, list.nth($shadow, 6), null);

                @if $shadowOpacity != null {
                    $shadowColor: rgba(red($shadowColor), green($shadowColor), blue($shadowColor), $shadowOpacity);
                }

                $shadows: list.append(
                    $shadows,
                    rem($shadowX) rem($shadowY) rem($shadowBlur) rem($shadowSpread) $shadowColor,
                    comma
                );
            }
            & {
                box-shadow: $shadows;
            }
        } @else {
            // Одна тень передана как список значений
            $shadowX: list.nth($x, 1);
            $shadowY: list.nth($x, 2);
            $shadowBlur: list.nth($x, 3);
            $shadowSpread: list.nth($x, 4);
            $shadowColor: list.nth($x, 5);
            
            & {
                box-shadow: rem($shadowX) rem($shadowY) rem($shadowBlur) rem($shadowSpread) $shadowColor;
            }
        }
    } @else {
        // Обычная тень с отдельными параметрами
        @if $opacity != null {
            $color: rgba(red($color), green($color), blue($color), $opacity);
        }

        & {
            box-shadow: rem($x) rem($y) rem($blur) rem($spread) $color;
        }
    }
}
